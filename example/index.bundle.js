/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./example/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/barrage.umd.js":
/*!*****************************!*\
  !*** ./dist/barrage.umd.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(this, function () {\n  'use strict';\n  /*! *****************************************************************************\n  Copyright (c) Microsoft Corporation. All rights reserved.\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n  this file except in compliance with the License. You may obtain a copy of the\n  License at http://www.apache.org/licenses/LICENSE-2.0\n   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n  MERCHANTABLITY OR NON-INFRINGEMENT.\n   See the Apache Version 2.0 License for specific language governing permissions\n  and limitations under the License.\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  function isEmptyArray(array) {\n    return array.length === 0;\n  }\n\n  function getArrayRight(array) {\n    return array[array.length - 1];\n  }\n\n  function isDiv(el) {\n    return el instanceof HTMLDivElement;\n  }\n\n  function isCanvas(el) {\n    return el instanceof HTMLCanvasElement;\n  }\n\n  function getEl(el, type) {\n    var $ = document.querySelector;\n\n    var _el = typeof el === 'string' ? $(el) : el;\n\n    if (type === 'canvas' && !isCanvas(_el)) {\n      throwElError('canvas');\n    }\n\n    if (type === 'css3' && !isDiv(_el)) {\n      throwElError('css3');\n    }\n\n    return _el;\n\n    function throwElError(type) {\n      var EL_TYPE = type === 'canvas' ? 'HTMLCanvasElement' : 'HTMLDivElement';\n      throw new Error(\"Engine Error: el is not a \" + EL_TYPE + \" instance.(engine: \" + type + \")\");\n    }\n  }\n\n  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\n  var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\n\n  var isNull = function isNull(o) {\n    return o === null;\n  };\n\n  var isUndefined = function isUndefined(o) {\n    return typeof o === 'undefined';\n  };\n\n  var isPlainObject = function isPlainObject(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n  };\n\n  function deepMerge() {\n    var objects = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      objects[_i] = arguments[_i];\n    }\n\n    var ret = {};\n    objects.forEach(function (obj) {\n      if (isNull(obj) || isUndefined(obj)) {\n        return;\n      }\n\n      Object.keys(obj).forEach(function (key) {\n        if (!ret.hasOwnProperty(key)) {\n          ret[key] = obj[key];\n        } else {\n          if (Array.isArray(obj[key])) {\n            ret[key] = obj[key];\n          } else if (isPlainObject(obj[key])) {\n            ret[key] = deepMerge(ret[key], obj[key]);\n          } else {\n            ret[key] = obj[key];\n          }\n        }\n      });\n    });\n    return ret;\n  }\n\n  function isScrollBarrage(x) {\n    return x.hasOwnProperty('speed') && x.hasOwnProperty('offset');\n  }\n\n  var EventEmitter =\n  /** @class */\n  function () {\n    function EventEmitter() {\n      this._eventsMap = {};\n    }\n\n    EventEmitter.prototype.$on = function (eventName, handler) {\n      var eventsMap = this._eventsMap;\n      var handlers = eventsMap[eventName] || (eventsMap[eventName] = []);\n      handlers.push(handler);\n      return this;\n    };\n\n    EventEmitter.prototype.$once = function (eventName, handler) {\n      var eventsMap = this._eventsMap;\n      var handlers = eventsMap[eventName] || (eventsMap[eventName] = []);\n      var self = this;\n\n      var fn = function fn() {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        handler.apply(void 0, args);\n        self.$off(eventName, fn);\n      };\n\n      handlers.push(fn);\n      return this;\n    };\n\n    EventEmitter.prototype.$off = function (eventName, handler) {\n      var eventsMap = this._eventsMap;\n\n      if (!handler) {\n        eventsMap[eventName].length = 0;\n        return this;\n      }\n\n      var handlers = eventsMap[eventName];\n\n      if (!handlers) {\n        return this;\n      }\n\n      var index = handlers.indexOf(handler);\n\n      if (index !== -1) {\n        handlers.splice(index, 1);\n      }\n\n      return this;\n    };\n\n    EventEmitter.prototype.$emit = function (eventName) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      var eventsMap = this._eventsMap;\n      var handlers = eventsMap[eventName];\n\n      if (Array.isArray(handlers)) {\n        handlers.forEach(function (fn) {\n          return fn.apply(void 0, args);\n        });\n      }\n    };\n\n    return EventEmitter;\n  }();\n\n  var BarrageTrack =\n  /** @class */\n  function () {\n    function BarrageTrack() {\n      this.barrages = [];\n      this.offset = 0;\n    }\n\n    BarrageTrack.prototype.forEach = function (handler) {\n      for (var i = 0; i < this.barrages.length; ++i) {\n        handler(this.barrages[i], i, this.barrages);\n      }\n    };\n\n    BarrageTrack.prototype.reset = function () {\n      this.barrages = [];\n      this.offset = 0;\n    };\n\n    BarrageTrack.prototype.push = function () {\n      var _a;\n\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      (_a = this.barrages).push.apply(_a, items);\n    };\n\n    BarrageTrack.prototype.removeTop = function () {\n      this.barrages.shift();\n    };\n\n    BarrageTrack.prototype.remove = function (index) {\n      if (index < 0 || index >= this.barrages.length) {\n        return;\n      }\n\n      this.barrages.splice(index, 1);\n    };\n\n    BarrageTrack.prototype.updateOffset = function () {\n      var endBarrage = this.barrages[this.barrages.length - 1];\n\n      if (endBarrage && isScrollBarrage(endBarrage)) {\n        var speed = endBarrage.speed;\n        this.offset -= speed;\n      }\n    };\n\n    return BarrageTrack;\n  }();\n\n  var BaseCommander =\n  /** @class */\n  function (_super) {\n    __extends(BaseCommander, _super);\n\n    function BaseCommander(config) {\n      var _this = _super.call(this) || this;\n\n      _this.tracks = [];\n      _this.waitingQueue = [];\n      _this.trackWidth = config.trackWidth;\n      _this.trackHeight = config.trackHeight;\n      _this.duration = config.duration;\n      _this.maxTrack = config.maxTrack;\n\n      for (var i = 0; i < config.maxTrack; ++i) {\n        _this.tracks[i] = new BarrageTrack();\n      }\n\n      return _this;\n    }\n\n    BaseCommander.prototype.forEach = function (handler) {\n      for (var i = 0; i < this.tracks.length; ++i) {\n        handler(this.tracks[i], i, this.tracks);\n      }\n    }; // reset() {\n    //   this.forEach(track => track.reset())\n    // }\n\n\n    BaseCommander.prototype.resize = function (width, height) {\n      if (width) {\n        this.trackWidth = width;\n      }\n\n      if (height) {\n        this.trackHeight = height;\n      }\n    };\n\n    return BaseCommander;\n  }(EventEmitter);\n\n  var BaseCanvasCommander =\n  /** @class */\n  function (_super) {\n    __extends(BaseCanvasCommander, _super);\n\n    function BaseCanvasCommander(canvas, config) {\n      var _this = _super.call(this, config) || this;\n\n      _this.canvas = canvas;\n      _this.ctx = canvas.getContext('2d');\n      return _this;\n    }\n\n    BaseCanvasCommander.prototype.reset = function () {\n      this.forEach(function (track) {\n        return track.reset();\n      });\n    };\n\n    return BaseCanvasCommander;\n  }(BaseCommander);\n\n  var BaseFixedCommander =\n  /** @class */\n  function (_super) {\n    __extends(BaseFixedCommander, _super);\n\n    function BaseFixedCommander(canvas, config) {\n      return _super.call(this, canvas, config) || this;\n    }\n\n    BaseFixedCommander.prototype.add = function (barrage) {\n      var trackId = this._findTrack();\n\n      if (trackId === -1) {\n        return false;\n      }\n\n      var track = this.tracks[trackId];\n      var trackWidth = this.trackWidth;\n      var width = barrage.width;\n      var barrageOffset = (trackWidth - width) / 2;\n      var normalizedBarrage = Object.assign({}, barrage, {\n        offset: barrageOffset,\n        duration: this.duration\n      });\n      track.push(normalizedBarrage);\n      return true;\n    };\n\n    BaseFixedCommander.prototype._findTrack = function () {\n      var idx = -1;\n\n      for (var i = 0; i < this.tracks.length; ++i) {\n        if (isEmptyArray(this.tracks[i].barrages)) {\n          idx = i;\n          break;\n        }\n      }\n\n      return idx;\n    };\n\n    BaseFixedCommander.prototype._extractBarrage = function () {\n      var isIntered;\n\n      for (var i = 0; i < this.waitingQueue.length;) {\n        isIntered = this.add(this.waitingQueue[i]);\n\n        if (!isIntered) {\n          break;\n        }\n\n        this.waitingQueue.shift();\n      }\n    };\n\n    return BaseFixedCommander;\n  }(BaseCanvasCommander);\n\n  var HTML_ELEMENT_NATIVE_EVENTS = 'click,dblclick,mousedown,mousemove,mouseout,mouseover,mouseup'.split(',');\n  var TIME_PER_FRAME = 16.6;\n\n  var FixedTopCommander =\n  /** @class */\n  function (_super) {\n    __extends(FixedTopCommander, _super);\n\n    function FixedTopCommander(canvas, config) {\n      return _super.call(this, canvas, config) || this;\n    }\n\n    FixedTopCommander.prototype.render = function () {\n      this._extractBarrage();\n\n      var ctx = this.ctx;\n      var trackHeight = this.trackHeight;\n      this.tracks.forEach(function (track, index) {\n        var barrage = track.barrages[0];\n\n        if (!barrage) {\n          return;\n        }\n\n        var color = barrage.color,\n            text = barrage.text,\n            offset = barrage.offset,\n            size = barrage.size;\n        ctx.fillStyle = color;\n        ctx.font = size + \"px 'Microsoft Yahei'\";\n        ctx.fillText(text, offset, (index + 1) * trackHeight);\n        barrage.duration -= TIME_PER_FRAME;\n\n        if (barrage.duration <= 0) {\n          track.removeTop();\n        }\n      });\n    };\n\n    return FixedTopCommander;\n  }(BaseFixedCommander);\n\n  var FixedBottomCommander =\n  /** @class */\n  function (_super) {\n    __extends(FixedBottomCommander, _super);\n\n    function FixedBottomCommander(canvas, config) {\n      return _super.call(this, canvas, config) || this;\n    }\n\n    FixedBottomCommander.prototype.render = function () {\n      this._extractBarrage();\n\n      var ctx = this.ctx;\n      var trackHeight = this.trackHeight;\n      var canvasHeight = this.canvas.height;\n      var startY = canvasHeight - this.trackHeight * this.tracks.length;\n      this.tracks.forEach(function (track, index) {\n        var barrage = track.barrages[0];\n\n        if (!barrage) {\n          return;\n        }\n\n        var color = barrage.color,\n            text = barrage.text,\n            offset = barrage.offset,\n            size = barrage.size;\n        ctx.fillStyle = color;\n        ctx.font = size + \"px 'Microsoft Yahei'\";\n        ctx.fillText(text, offset, startY + index * trackHeight);\n        barrage.duration -= TIME_PER_FRAME;\n\n        if (barrage.duration <= 0) {\n          track.removeTop();\n        }\n      });\n    };\n\n    return FixedBottomCommander;\n  }(BaseFixedCommander);\n\n  var RollingCommander =\n  /** @class */\n  function (_super) {\n    __extends(RollingCommander, _super);\n\n    function RollingCommander(canvas, config) {\n      return _super.call(this, canvas, config) || this;\n    }\n\n    Object.defineProperty(RollingCommander.prototype, \"_defaultSpeed\", {\n      get: function get() {\n        return this.trackWidth / this.duration * TIME_PER_FRAME;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(RollingCommander.prototype, \"_randomSpeed\", {\n      get: function get() {\n        return 0.8 + Math.random() * 1.3;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    RollingCommander.prototype.add = function (barrage) {\n      var trackId = this._findTrack();\n\n      if (trackId === -1) {\n        return false;\n      }\n\n      var track = this.tracks[trackId];\n      var trackOffset = track.offset;\n      var trackWidth = this.trackWidth;\n      var speed;\n\n      if (isEmptyArray(track.barrages)) {\n        speed = this._defaultSpeed * this._randomSpeed;\n      } else {\n        var preSpeed = getArrayRight(track.barrages).speed;\n        speed = trackWidth * preSpeed / trackOffset;\n      }\n\n      speed = Math.min(speed, this._defaultSpeed * 2);\n      var normalizedBarrage = Object.assign({}, barrage, {\n        offset: trackWidth,\n        speed: speed\n      });\n      track.push(normalizedBarrage);\n      track.offset = trackWidth + barrage.width * 1.2;\n      return true;\n    };\n\n    RollingCommander.prototype._findTrack = function () {\n      var _this = this;\n\n      var idx = -1;\n      var max = -Infinity;\n      this.forEach(function (track, index) {\n        var trackOffset = track.offset;\n\n        if (trackOffset > _this.trackWidth) {\n          return;\n        }\n\n        var t = _this.trackWidth - trackOffset;\n\n        if (t > max) {\n          idx = index;\n          max = t;\n        }\n      });\n      return idx;\n    };\n\n    RollingCommander.prototype._extractBarrage = function () {\n      var isIntered;\n\n      for (var i = 0; i < this.waitingQueue.length;) {\n        isIntered = this.add(this.waitingQueue[i]);\n\n        if (!isIntered) {\n          break;\n        }\n\n        this.waitingQueue.shift();\n      }\n    };\n\n    RollingCommander.prototype.render = function () {\n      this._extractBarrage();\n\n      var ctx = this.ctx;\n      var trackHeight = this.trackHeight;\n      this.forEach(function (track, trackIndex) {\n        var removeTop = false;\n        track.forEach(function (barrage, barrageIndex) {\n          var color = barrage.color,\n              text = barrage.text,\n              offset = barrage.offset,\n              speed = barrage.speed,\n              width = barrage.width,\n              size = barrage.size;\n          ctx.fillStyle = color;\n          ctx.font = size + \"px 'Microsoft Yahei'\";\n          ctx.fillText(text, offset, (trackIndex + 1) * trackHeight);\n          barrage.offset -= speed;\n\n          if (barrageIndex === 0 && barrage.offset < 0 && Math.abs(barrage.offset) >= width) {\n            removeTop = true;\n          }\n        });\n        track.updateOffset();\n\n        if (removeTop) {\n          track.removeTop();\n        }\n      });\n    };\n\n    return RollingCommander;\n  }(BaseCanvasCommander);\n\n  var engine = {\n    FixedBottomCommander: FixedBottomCommander,\n    FixedTopCommander: FixedTopCommander,\n    RollingCommander: RollingCommander\n  };\n\n  function createElement(tagName) {\n    return document.createElement(tagName);\n  }\n\n  function createBarrage(text, color, fontSize, left) {\n    var danmu = createElement('div');\n    setStyle(danmu, {\n      position: 'absolute',\n      color: color,\n      fontSize: fontSize,\n      transform: \"translateX(\" + left + \"px)\",\n      textShadow: '#000 1px 0 0, #000 0 1px 0, #000 -1px 0 0, #000 0 -1px 0',\n      pointerEvents: 'auto',\n      padding: '3px 20px',\n      borderRadius: '20px',\n      backgroundColor: 'transparent'\n    });\n    danmu.textContent = text;\n    return danmu;\n  }\n\n  function appendChild(parent, child) {\n    return parent.appendChild(child);\n  }\n\n  function setStyle(el, style) {\n    for (var key in style) {\n      el.style[key] = style[key];\n    }\n  }\n\n  function setHoverStyle(el) {\n    el.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n    el.style.cursor = 'pointer';\n  }\n\n  function setBlurStyle(el) {\n    el.style.backgroundColor = 'transparent';\n    el.style.cursor = 'auto';\n  }\n\n  var BaseCssCommander =\n  /** @class */\n  function (_super) {\n    __extends(BaseCssCommander, _super);\n\n    function BaseCssCommander(el, config) {\n      var _this = _super.call(this, config) || this;\n\n      _this.objToElm = new WeakMap();\n      _this.elmToObj = new WeakMap();\n      _this.freezeBarrage = null;\n      _this.el = el;\n      var wrapper = config.wrapper;\n\n      if (wrapper && config.interactive) {\n        wrapper.addEventListener('mousemove', _this._mouseMoveEventHandler.bind(_this));\n        wrapper.addEventListener('click', _this._mouseClickEventHandler.bind(_this));\n      }\n\n      return _this;\n    }\n\n    BaseCssCommander.prototype.removeElement = function (target) {\n      this.el.removeChild(target);\n    };\n\n    BaseCssCommander.prototype._mouseMoveEventHandler = function (e) {\n      var target = e.target;\n\n      if (!target) {\n        return;\n      }\n\n      var newFreezeBarrage = this.elmToObj.get(target);\n      var oldFreezeBarrage = this.freezeBarrage;\n\n      if (newFreezeBarrage === oldFreezeBarrage) {\n        return;\n      }\n\n      this.freezeBarrage = null;\n\n      if (newFreezeBarrage) {\n        this.freezeBarrage = newFreezeBarrage;\n        newFreezeBarrage.freeze = true;\n        setHoverStyle(target);\n        this.$emit('hover', newFreezeBarrage, target);\n      }\n\n      if (oldFreezeBarrage) {\n        oldFreezeBarrage.freeze = false;\n        var oldFreezeElm = this.objToElm.get(oldFreezeBarrage);\n        oldFreezeElm && setBlurStyle(oldFreezeElm);\n        this.$emit('blur', oldFreezeBarrage, oldFreezeElm);\n      }\n    };\n\n    BaseCssCommander.prototype._mouseClickEventHandler = function (e) {\n      var target = e.target;\n      var barrageObject = this.elmToObj.get(target);\n\n      if (barrageObject) {\n        this.$emit('click', barrageObject, target);\n      }\n    };\n\n    BaseCssCommander.prototype.reset = function () {\n      var _this = this;\n\n      this.forEach(function (track) {\n        track.forEach(function (barrage) {\n          var el = _this.objToElm.get(barrage);\n\n          if (!el) {\n            return;\n          }\n\n          _this.removeElement(el);\n        });\n        track.reset();\n      });\n    };\n\n    return BaseCssCommander;\n  }(BaseCommander);\n\n  var BaseFixedCssCommander =\n  /** @class */\n  function (_super) {\n    __extends(BaseFixedCssCommander, _super);\n\n    function BaseFixedCssCommander(el, config) {\n      var _this = _super.call(this, el, config) || this;\n\n      _this.elHeight = el.offsetHeight;\n      return _this;\n    }\n\n    BaseFixedCssCommander.prototype.add = function (barrage) {\n      var trackId = this._findTrack();\n\n      if (trackId === -1) {\n        return false;\n      } // 创建弹幕DOM\n\n\n      var text = barrage.text,\n          size = barrage.size,\n          color = barrage.color,\n          offset = barrage.offset;\n      var fontSize = size + 'px';\n      var posLeft = offset + 'px';\n      var danmu = createBarrage(text, color, fontSize, posLeft);\n      appendChild(this.el, danmu);\n      var width = danmu.offsetWidth; // 计算位置\n\n      var track = this.tracks[trackId];\n      var trackWidth = this.trackWidth;\n      var barrageOffset = (trackWidth - width) / 2;\n      var normalizedBarrage = Object.assign({}, barrage, {\n        offset: barrageOffset,\n        duration: this.duration,\n        width: width\n      });\n      this.objToElm.set(normalizedBarrage, danmu);\n      this.elmToObj.set(danmu, normalizedBarrage);\n      track.push(normalizedBarrage);\n      return true;\n    };\n\n    BaseFixedCssCommander.prototype._findTrack = function () {\n      var idx = -1;\n\n      for (var i = 0; i < this.tracks.length; ++i) {\n        if (isEmptyArray(this.tracks[i].barrages)) {\n          idx = i;\n          break;\n        }\n      }\n\n      return idx;\n    };\n\n    BaseFixedCssCommander.prototype._extractBarrage = function () {\n      var isIntered;\n\n      for (var i = 0; i < this.waitingQueue.length;) {\n        isIntered = this.add(this.waitingQueue[i]);\n\n        if (!isIntered) {\n          break;\n        }\n\n        this.waitingQueue.shift();\n      }\n    };\n\n    BaseFixedCssCommander.prototype._removeTopElementFromTrack = function (track) {\n      var barrage = track.barrages[0];\n\n      if (!barrage) {\n        return;\n      }\n\n      var el = this.objToElm.get(barrage);\n      this.objToElm[\"delete\"](barrage);\n      this.elmToObj[\"delete\"](el);\n      this.removeElement(el);\n    };\n\n    return BaseFixedCssCommander;\n  }(BaseCssCommander);\n\n  var FixedTopCommander$1 =\n  /** @class */\n  function (_super) {\n    __extends(FixedTopCommander, _super);\n\n    function FixedTopCommander(el, config) {\n      return _super.call(this, el, config) || this;\n    }\n\n    FixedTopCommander.prototype.render = function () {\n      var _this = this;\n\n      this._extractBarrage();\n\n      var objToElm = this.objToElm;\n      var trackHeight = this.trackHeight;\n      this.tracks.forEach(function (track, trackIndex) {\n        var barrage = track.barrages[0];\n\n        if (!barrage) {\n          return;\n        }\n\n        var el = objToElm.get(barrage);\n\n        if (!el) {\n          return;\n        }\n\n        if (barrage.freeze) {\n          return;\n        }\n\n        var offset = barrage.offset;\n        var y = trackIndex * trackHeight;\n        el.style.transform = \"translate(\" + offset + \"px, \" + y + \"px)\";\n        barrage.duration -= TIME_PER_FRAME;\n\n        if (barrage.duration <= 0) {\n          _this._removeTopElementFromTrack(track);\n\n          track.removeTop();\n        }\n      });\n    };\n\n    return FixedTopCommander;\n  }(BaseFixedCssCommander);\n\n  var RollingCssCommander =\n  /** @class */\n  function (_super) {\n    __extends(RollingCssCommander, _super);\n\n    function RollingCssCommander(el, config) {\n      return _super.call(this, el, config) || this;\n    }\n\n    Object.defineProperty(RollingCssCommander.prototype, \"_defaultSpeed\", {\n      get: function get() {\n        return this.trackWidth / this.duration * TIME_PER_FRAME;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(RollingCssCommander.prototype, \"_randomSpeed\", {\n      get: function get() {\n        return 0.8 + Math.random() * 1.3;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    RollingCssCommander.prototype.add = function (barrage) {\n      var trackId = this._findTrack();\n\n      if (trackId === -1) {\n        return false;\n      } // 创建弹幕DOM\n\n\n      var text = barrage.text,\n          size = barrage.size,\n          color = barrage.color,\n          offset = barrage.offset;\n      var fontSize = size + 'px';\n      var posLeft = offset + 'px';\n      var danmu = createBarrage(text, color, fontSize, posLeft);\n      appendChild(this.el, danmu);\n      var width = danmu.offsetWidth; // 计算弹幕速度\n\n      var track = this.tracks[trackId];\n      var trackOffset = track.offset;\n      var trackWidth = this.trackWidth;\n      var speed;\n\n      if (isEmptyArray(track.barrages)) {\n        speed = this._defaultSpeed * this._randomSpeed;\n      } else {\n        var preSpeed = getArrayRight(track.barrages).speed;\n        speed = trackWidth * preSpeed / trackOffset;\n      }\n\n      speed = Math.min(speed, this._defaultSpeed * 2);\n      var normalizedBarrage = Object.assign({}, barrage, {\n        offset: trackWidth,\n        speed: speed,\n        width: width\n      });\n      this.objToElm.set(normalizedBarrage, danmu);\n      this.elmToObj.set(danmu, normalizedBarrage);\n      track.push(normalizedBarrage);\n      track.offset = trackWidth + normalizedBarrage.width * 1.2;\n      return true;\n    };\n\n    RollingCssCommander.prototype._findTrack = function () {\n      var _this = this;\n\n      var idx = -1;\n      var max = -Infinity;\n      this.forEach(function (track, index) {\n        var trackOffset = track.offset;\n\n        if (trackOffset > _this.trackWidth) {\n          return;\n        }\n\n        var t = _this.trackWidth - trackOffset;\n\n        if (t > max) {\n          idx = index;\n          max = t;\n        }\n      });\n      return idx;\n    };\n\n    RollingCssCommander.prototype._extractBarrage = function () {\n      var isIntered;\n\n      for (var i = 0; i < this.waitingQueue.length;) {\n        isIntered = this.add(this.waitingQueue[i]);\n\n        if (!isIntered) {\n          break;\n        }\n\n        this.waitingQueue.shift();\n      }\n    };\n\n    RollingCssCommander.prototype.render = function () {\n      var _this = this;\n\n      this._extractBarrage();\n\n      var objToElm = this.objToElm;\n      var trackHeight = this.trackHeight;\n      this.forEach(function (track, trackIndex) {\n        var shouldRemove = false;\n        var shouldRemoveIndex = -1;\n        track.forEach(function (barrage, barrageIndex) {\n          if (!objToElm.has(barrage)) {\n            return;\n          }\n\n          if (barrage.freeze) {\n            return;\n          }\n\n          var el = objToElm.get(barrage);\n          var offset = barrage.offset;\n          el.style.transform = \"translate(\" + offset + \"px, \" + trackIndex * trackHeight + \"px)\";\n          barrage.offset -= barrage.speed;\n\n          if (barrage.offset < 0 && Math.abs(barrage.offset) > barrage.width) {\n            shouldRemove = true;\n            shouldRemoveIndex = barrageIndex;\n          }\n        });\n        track.updateOffset();\n\n        if (shouldRemove) {\n          _this._removeElementFromTrack(track, shouldRemoveIndex);\n\n          track.remove(shouldRemoveIndex);\n        }\n      });\n    };\n\n    RollingCssCommander.prototype._removeElementFromTrack = function (track, removedIndex) {\n      var barrage = track.barrages[removedIndex];\n\n      if (!barrage) {\n        return;\n      }\n\n      var el = this.objToElm.get(barrage);\n      this.objToElm[\"delete\"](barrage);\n      this.elmToObj[\"delete\"](el);\n      this.removeElement(el);\n    };\n\n    return RollingCssCommander;\n  }(BaseCssCommander);\n\n  var FixedTopCommander$2 =\n  /** @class */\n  function (_super) {\n    __extends(FixedTopCommander, _super);\n\n    function FixedTopCommander(el, config) {\n      return _super.call(this, el, config) || this;\n    }\n\n    FixedTopCommander.prototype.render = function () {\n      var _this = this;\n\n      this._extractBarrage();\n\n      var objToElm = this.objToElm;\n      var trackHeight = this.trackHeight;\n      var maxTrack = this.maxTrack;\n      var elHeight = this.el.offsetHeight;\n      var yBase = elHeight - maxTrack * trackHeight;\n      this.tracks.forEach(function (track, trackIndex) {\n        var barrage = track.barrages[0];\n\n        if (!barrage) {\n          return;\n        }\n\n        var el = objToElm.get(barrage);\n\n        if (!el) {\n          return;\n        }\n\n        if (barrage.freeze) {\n          return;\n        }\n\n        var offset = barrage.offset;\n        var y = yBase + trackIndex * trackHeight;\n        el.style.transform = \"translate(\" + offset + \"px, \" + y + \"px)\";\n        barrage.duration -= TIME_PER_FRAME;\n\n        if (barrage.duration <= 0) {\n          _this._removeTopElementFromTrack(track);\n\n          track.removeTop();\n        }\n      });\n    };\n\n    return FixedTopCommander;\n  }(BaseFixedCssCommander);\n\n  var engine$1 = {\n    FixedTopCommander: FixedTopCommander$1,\n    FixedBottomCommander: FixedTopCommander$2,\n    RollingCommander: RollingCssCommander\n  };\n\n  function getEngine(type) {\n    if (type === 'canvas') {\n      return engine;\n    }\n\n    if (type === 'css3') {\n      return engine$1;\n    }\n\n    return null;\n  }\n\n  function injectNativeEvents(instance) {\n    HTML_ELEMENT_NATIVE_EVENTS.map(function (eventName) {\n      instance.el.addEventListener(eventName, function (event) {\n        instance.$emit(eventName, event);\n      });\n    });\n  }\n\n  function injectEventsDelegator(instance) {\n    var proxyObject = instance.config.proxyObject;\n\n    if (!(proxyObject instanceof HTMLElement)) {\n      return;\n    }\n\n    HTML_ELEMENT_NATIVE_EVENTS.map(function (eventName) {\n      instance.el.addEventListener(eventName, function (e) {\n        var target = e.target;\n\n        if (target !== instance.el) {\n          return;\n        }\n\n        var event = new MouseEvent(eventName, {\n          view: window,\n          relatedTarget: proxyObject,\n          altKey: e.altKey,\n          button: e.button,\n          buttons: e.buttons,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          ctrlKey: e.ctrlKey,\n          metaKey: e.metaKey,\n          movementX: e.movementX,\n          movementY: e.movementY,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          shiftKey: e.shiftKey\n        });\n        proxyObject.dispatchEvent(event);\n      });\n    });\n  }\n\n  var CanvasStragy = {\n    clear: function clear() {\n      var _a = this.canvas,\n          width = _a.width,\n          height = _a.height;\n\n      this._forEachManager(function (manager) {\n        return manager.reset();\n      });\n\n      this.ctx.clearRect(0, 0, width, height);\n    },\n    add: function add(barrage, type) {\n      if (type === void 0) {\n        type = 'scroll';\n      }\n\n      var text = barrage.text,\n          color = barrage.color,\n          size = barrage.size;\n      var ctx = this.ctx;\n      var fontSize = (size || this.config.fontSize) * this.config.zoom;\n      var fontColor = color || this.config.fontColor;\n      ctx.font = fontSize + \"px 'Microsoft Yahei'\";\n      var width = ctx.measureText(text).width;\n\n      if (type === 'scroll') {\n        var barrageObject = {\n          text: text,\n          width: width,\n          color: fontColor,\n          size: fontSize,\n          speed: 0,\n          offset: 0\n        };\n        this.commanderMap[type].waitingQueue.push(barrageObject);\n      } else {\n        var barrageObject = {\n          text: text,\n          width: width,\n          color: fontColor,\n          size: fontSize,\n          duration: 0,\n          offset: 0\n        };\n        this.commanderMap[type].waitingQueue.push(barrageObject);\n      }\n    },\n    _render: function _render() {\n      var ctx = this.ctx;\n      var canvas = this.canvas;\n      ctx.shadowBlur = 2;\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      this._forEachManager(function (manager) {\n        return manager.render();\n      });\n\n      this.animation = requestAnimationFrame(this._render.bind(this));\n    }\n  }; // import { createBarrage, appendChild } from '../helper/css';\n\n  var Css3Stragy = {\n    clear: function clear() {\n      this._forEachManager(function (manager) {\n        return manager.reset();\n      });\n    },\n    add: function add(barrage, type) {\n      if (type === void 0) {\n        type = 'scroll';\n      }\n\n      var text = barrage.text,\n          _a = barrage.color,\n          color = _a === void 0 ? this.config.fontColor : _a,\n          _b = barrage.size,\n          size = _b === void 0 ? this.config.fontSize : _b;\n      var fontColor = color;\n      var fontSize = size * this.config.zoom;\n      var trackWidth = this.el.offsetWidth; // const posLeft = trackWidth + 'px';\n      // const danmu = createBarrage(text, fontColor, fontSize, posLeft);\n      // appendChild(this.el, danmu);\n      // const width = danmu.offsetWidth;\n\n      if (type === 'scroll') {\n        var barrageObject = {\n          text: text,\n          width: 0,\n          color: fontColor,\n          size: fontSize,\n          speed: 0,\n          offset: trackWidth\n        }; // (this.commanderMap[type] as RollingCssCommander).objToElm.set(barrageObject, danmu);\n\n        this.commanderMap[type].waitingQueue.push(barrageObject);\n      } else {\n        var barrageObject = {\n          text: text,\n          width: 0,\n          color: fontColor,\n          size: fontSize,\n          duration: this.config.duration,\n          offset: trackWidth\n        };\n        this.commanderMap[type].waitingQueue.push(barrageObject);\n      }\n    },\n    _render: function _render() {\n      this._forEachManager(function (manager) {\n        return manager.render();\n      });\n\n      this.animation = requestAnimationFrame$1(this._render.bind(this));\n    }\n  };\n\n  function getHandler(engine, fn) {\n    var fnMap = engine === 'canvas' ? CanvasStragy : Css3Stragy;\n    return fnMap[fn];\n  }\n\n  var defaultConfig = {\n    engine: 'canvas',\n    zoom: 1,\n    proxyObject: null,\n    usePointerEvents: true,\n    maxTrack: 4,\n    fontSize: 20,\n    fontColor: '#fff',\n    duration: 10000,\n    trackHeight: 20 * 1.5,\n    wrapper: null,\n    interactive: true\n  };\n\n  var BarrageMaker =\n  /** @class */\n  function (_super) {\n    __extends(BarrageMaker, _super);\n\n    function BarrageMaker(el, config) {\n      var _this = _super.call(this) || this;\n\n      _this.canvas = null;\n      _this.ctx = null;\n      _this.animation = null;\n      _this.config = deepMerge(defaultConfig, config || {});\n      console.log(_this.config);\n      _this.el = getEl(el, _this.config.engine);\n\n      if (isCanvas(_this.el)) {\n        _this.canvas = _this.el;\n        _this.ctx = _this.canvas.getContext('2d');\n      } // 兼容性：IE11+ / 非IE基本全支持\n      // pointer-events 避免上层canvas阻碍下层点击\n\n\n      if (_this.config.usePointerEvents) {\n        _this.el.style.pointerEvents = 'none';\n      } // 获取渲染引擎\n\n\n      var renderEngine = getEngine(_this.config.engine);\n      var commanderConfig = {\n        trackWidth: _this.el.offsetWidth,\n        trackHeight: _this.config.trackHeight,\n        maxTrack: _this.config.maxTrack,\n        duration: _this.config.duration,\n        wrapper: _this.config.wrapper,\n        interactive: _this.config.interactive\n      };\n      var rootEle = _this.config.engine === 'canvas' ? _this.canvas : _this.el;\n      _this.commanderMap = {\n        scroll: new renderEngine.RollingCommander(rootEle, commanderConfig),\n        'fixed-top': new renderEngine.FixedTopCommander(rootEle, commanderConfig),\n        'fixed-bottom': new renderEngine.FixedBottomCommander(rootEle, commanderConfig)\n      };\n\n      _this.resize(); // 注入事件控制逻辑\n\n\n      injectNativeEvents(_this);\n      injectEventsDelegator(_this);\n      return _this;\n    }\n\n    BarrageMaker.prototype.resize = function (width) {\n      width = width || this.el.offsetWidth;\n\n      this._forEachManager(function (manager) {\n        return manager.resize(width);\n      });\n    };\n\n    BarrageMaker.prototype.clear = function () {\n      var fn = getHandler(this.config.engine, 'clear');\n      return fn.call(this);\n    };\n\n    BarrageMaker.prototype.setOpacity = function (opacity) {\n      if (opacity === void 0) {\n        opacity = 1;\n      }\n\n      this.el.style.opacity = \"\" + opacity;\n    };\n\n    BarrageMaker.prototype.setFontSize = function (zoom) {\n      if (zoom === void 0) {\n        zoom = 1;\n      }\n\n      this.config.zoom = zoom;\n    };\n\n    BarrageMaker.prototype.add = function (barrage, type) {\n      if (type === void 0) {\n        type = 'scroll';\n      }\n\n      var fn = getHandler(this.config.engine, 'add');\n      return fn.call(this, barrage, type);\n    };\n\n    BarrageMaker.prototype.start = function () {\n      if (this.animation) {\n        return;\n      }\n\n      this.animation = requestAnimationFrame$1(this._render.bind(this));\n    };\n\n    BarrageMaker.prototype.stop = function () {\n      if (!this.animation) {\n        return;\n      }\n\n      cancelAnimationFrame(this.animation);\n      this.animation = null;\n    };\n\n    BarrageMaker.prototype.onBarrageHover = function (handler) {\n      this._bindBarrageEvent('hover', handler);\n    };\n\n    BarrageMaker.prototype.onBarrageBlur = function (handler) {\n      this._bindBarrageEvent('blur', handler);\n    };\n\n    BarrageMaker.prototype.onBarrageClick = function (handler) {\n      this._bindBarrageEvent('click', handler);\n    };\n\n    BarrageMaker.prototype._bindBarrageEvent = function (eventName, handler) {\n      if (this.config.engine === 'css3') {\n        this.commanderMap['scroll'].$on(eventName, handler);\n        this.commanderMap['fixed-top'].$on(eventName, handler);\n        this.commanderMap['fixed-bottom'].$on(eventName, handler);\n      }\n    };\n\n    BarrageMaker.prototype._forEachManager = function (handler) {\n      var _this = this;\n\n      Object.keys(this.commanderMap).forEach(function (key) {\n        return handler.call(_this, _this.commanderMap[key]);\n      });\n    };\n\n    BarrageMaker.prototype._render = function () {\n      var fn = getHandler(this.config.engine, '_render');\n      return fn.call(this);\n    };\n\n    return BarrageMaker;\n  }(EventEmitter);\n\n  return BarrageMaker;\n});\n\n//# sourceURL=webpack:///./dist/barrage.umd.js?");

/***/ }),

/***/ "./example/src/index.js":
/*!******************************!*\
  !*** ./example/src/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_barrage_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/barrage.umd */ \"./dist/barrage.umd.js\");\n/* harmony import */ var _dist_barrage_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dist_barrage_umd__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction getRandomWord() {\n  var words = ['Thanks for visiting!', 'ABarrage弹幕库', '干杯！！！🍻'];\n  var index = Math.floor(Math.random() * 3);\n  return words[index];\n}\n\nfunction mockBarrage() {\n  return {\n    text: getRandomWord(),\n    color: '#fff'\n  };\n}\n\nvar $ = function $(selector) {\n  return document.querySelector(selector);\n};\n\nvar danmu = $('#danmu');\nvar barrage = new _dist_barrage_umd__WEBPACK_IMPORTED_MODULE_0___default.a(danmu, {\n  fontSize: 40,\n  duration: 8000,\n  trackHeight: 40 * 1.5,\n  engine: 'canvas',\n  usePointerEvents: true\n});\n\nvar buildBarrageHandler = function buildBarrageHandler() {\n  var BUILD_COUNT = 20;\n\n  for (var i = 0; i < BUILD_COUNT; ++i) {\n    var text = mockBarrage();\n    barrage.add(text, 'scroll');\n  }\n\n  setTimeout(buildBarrageHandler, 5000);\n};\n\nbuildBarrageHandler();\nvar rect = document.body.getBoundingClientRect();\ndanmu.width = rect.width;\ndanmu.height = rect.height;\nbarrage.start();\n\n//# sourceURL=webpack:///./example/src/index.js?");

/***/ })

/******/ });